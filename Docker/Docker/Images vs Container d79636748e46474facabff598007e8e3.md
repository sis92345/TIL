# Images vs Container

# Container

<aside>
🪣 격리된 하나의 소프트웨어 유닛

</aside>

하나의 이미지에서 여러개의 컨테이너를 생성할 수 있으며 서로의 컨테이너는 같은 이미지라도 격리된 상태를 지닌다.

# Image

<aside>
🪣 Container의 블루프린트, 코드와 도구 종속성을 포함하며 컨테이너가 되어 코드를 실행

</aside>

하나의 이미지를 사용하여 여러개의 컨테이너를 사용할 수 있다. 

참고로 이미지는 한번 생성 후 소스가 변경되면 다시 빌드해야 한다. 쉽게 말해 스냅샷이다.

## Image는 읽기 전용이다.

이미지 빌드 후 소스가 수정되면 이미지 빌드 후에 이미지를 반영할 수 있다.

## Image는 Layer 기반이다.

> 이미지의 모든 명령은 캐시 가능한 레이어를 생성한다. 레이어는 이미지 재구축 및 공유를 돕는다.
> 

Docker는 Dockerfile 명령어를 기반으로 코드나 명령어가 변경되지 않았으면 이전에 캐시된 결과를 사용한다. 

쉽게 말해 다시 실행해야 하는 항목만 다시 실행하여 이미지 구축 속도를 높인다.

최종 명령 이전의 모든 명령어는 이미지의 일부이지만 별도의 레이어이다. 예를 들어 소스를 변경하면 COPY 명령어만 다시 실행한다. 그 이후 레이어는 캐시된 것을 사용할 수 없으므로 다시 실행한다.

### Container는 image위에 명령 Layer가 추가된 부가 레이어이다.

![Untitled](Images%20vs%20Container%20d79636748e46474facabff598007e8e3/Untitled.png)

따라서 Container는 한 이미지의 코드를 복사하지 않고 이미지 내부의 코드를 공유한다. 

따라서 이미지 내부 코드도 잠겨있다. 읽기 전용 컨테이너만 변경할 수 있다.

도커 이미지에 대한 새부 정보는 docker inspect 명령어로 얻을 수 있다.

> `docker inspectd [containerI]`
> 

# Images vs Container

<aside>
🪣 docker는 image를 기반으로 하는 Container를 실행한다.

</aside>

즉 **이미지는 모든 설정 명령과 모든 코드를 포함하는 공유 가능한 패키지**이다.

**이미지를 인스턴스화 한 것이 바로 Container**이다.