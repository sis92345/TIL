> 변수란?
>
- 수학적 의미: ‘변수變數’를 ’변하는 수’
- 프로그래밍적 의미: 변수(variable)란, 값을 저장 할 수 있는 메모리상의 공간을 의미
    - 이 공간에 저장된 값은 변경 될 수 있어 변수라는 수학적 정의와 상통한다.
- 하나의 변수에는 단 하나의 값만 저장할 수 있다.
    - 새로운 값을 저장하면 이전의 값은 사라진다.

## 변수의 선언과 초기화

변수를 사용하려면 먼저 변수를 초기화 해야 한다.

```java
 int age; //age라는 이름의 변수를 선언
```

1. 변수 타입 설정
2. 변수 이름 설정

변수의 사용은 변수 이름으로 사용하게 된다.

### 변수 초기화

변수를 사용하려면 반드시 ’초기화(initialization)’해야한다. 메모리는 여러 프로그램이 공유하는 자원이므로 전에 다른 프로그램에 의해 저장된 ’알 수 없는 값(쓰레기값 garbage value)’이 남아있을 수 있기 때문

변수를 초기화 할때는 ’=’대입 연산자를 사용한다.

안하면 컴파일 오류가 발생한다. 메모리에 올라가지 않으므로

’=’의 의미 - 수학적 의미: 양변이 같다 - 프로그래밍적 의미 : 오른쪽 값은 왼쪽 변수에 저장하라

ex)

```java
int age = 25;
```

img.png

```java
int a;int b;int x =0;int y = 0;
```

```java
int a , b;int x = 0 , y = 0;
```

위 아래 코드는 모두 같은 코드이다.

### 두 변수의 값 교환하기

다음과 같은 x,y 두 변수 가 있을때 두 변수의 값을 바꿀려면 어떻게 할까?

```java
int x = 10;int y = 20;
```

위 그림처럼 하면 변수는 모두 같은 값으로 변하게 될것이다. 이미 x 값은 y로 바뀌었기 때문에 이전의 x 값은 존재하지 않기 때문이다.

위 방법 말고 우리는 임시 변수를 만들어 값을 할당하고 사용한다

```java
int x = 10;int y = 20;int tmp;
```

두변수는 값을 교환하는 것은 마치 두 컵에 담긴 내용뮬을 바꾸려면 컵이 하나 더 필요한 것과 같다.

## 변수의 명명규칙

> 프로그래밍에서 사용하는 모든 이름을 ’식별자(identifier)’라 칭한다 식별자는 같은 영역 내에서 서로 구분 될 수 있어야 한다.
>

식별자를 만들때는 반드시 아래의 규칙을 지켜야한다.

> 대소문자가 구분되며 길이에 제한이 없어야 한다
>
> - True와 true는 서로 다른 것으로 간주한다
> 1. 예약어를 사용해서는 안된다
     >     - true는 예약어라서 사용할 수 없지만, True는 가능하다
> 2. 숫자로 시작해서는 안된다.
     >     - top10은 가능자만 7up은 허용되지 않는다.
> 3. 특수문자는 ’_‘와’$’만 허용한다
     >     - $harp은 허용되지만, S#arp은 허용하지 않는다

예약어는 키워드 또는 리져브드 워드(reserved word) 라고한다.

---

### 예약어 종류

---

> 클래스 이름의 첫 글자는 항상 대문자로 한다. -> 파스칼 케이스
>
> - 변수와 메서드의 이름의 첫 글자는 항상 소문자로 한다. ->
> 1. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.
     >     - lastIndexOf, StringBuffer
> 2. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 ’_’로 구분한다.
> - PI,MAX_NUMBER

위의 규칙들은 반드시 지켜져야 하는건 아니지만 개발자의 암묵적인 룰로 정해져 내려온다.

나만의 규칙을 만들시 모든 파일의 명명 규칙을 일관되게 해야 한다.

---

## 2. 변수의 타입

변수 타입은 크게 문자 , 숫자로 나눌 수 있다.

이 변수의 타입을 자세히 공부해 본다.

### 기본형과 참조형

---

> #### 기본형(primitive type) > > - 논리형(boolean),문자형(char),정수형(byte,short,int,long),실수형(float,double) 계산을 위한 실제 값을 저장한다. 모두 8개 > - 메모리에 저장된 값은 실제 값이다. > #### 참조형(reference type) > - 객체의 주소를 저장한다. 8개의 기본형을 제외한 나머지 타입 > - 메모리에 저장된 값은 참조하고 있는 메모리의 주소이다.

---

Java는 C언어와 다르게 참조형은 변수간의 연산을 할 수 없다 -> 실제 연산에 사용되는 변수는 모두 기본형

---

#### 참조형 변수를 선언하는 방법 > #### 클래스이름 변수이름; // 변수의 타입이 기본형이 아닌 것들은 모두 참조변수이다. >예시 >> Date today = new Date(); // Date객체를 생성해서, 그 주소를 today에 저장

---

### 2.1 기본형(primitive type)

위 와 같이 정의되며 문자형인 char는 문자를 내부적으로 정수(유니코드)로 저장하기 때문에 정수형과 별반 다르지 않다.

boolean을 제외한 나머지 7개의 기본형은 서로 연산과 변환이 가능하다.

정수는 가장 많이 사용되므로 타입을 4가지나 제공한다. 각 타입마다 저장할 수 있는 값의 범위가 다르므로 저장할 값의 범위에 맞는 타입을 선택 하면 된다.

### 각 타입이 저장할 수 있는 값의 범위


> int 범위 계산 예시 > 2¹0 = 1024 = 10³0, 231= 2¹0x2¹0 x 2¹0 x2 = 1024x1024x1024x2 = 2×10⁹
>

## 2.2 상수와 리터럴(constant & literal)

---

### 상수

---

- #### 상수: 변수와 같이 값을 저장할 수 있는 공간이지만 한번 값을 지정하면 변경 할 수 없다.

---

#### 상수 선언 방법 > final 변수타입 변수이름 = 값

---

상수의 이름은 무조건 대문자가 암묵적인 룰

---

### 리터럴 - #### 리터럴: 상수값들이지만 그 값들을 이름 자체로 정의해 버린 상수 ex) π 등

---

#### 예시

---

> final 변수타입 상수 = 리터럴

---

라고 생각하면 될거 같다

---

### 상수를 쓰는 이유

---

리터럴로 그냥 공식을 구해 버리면 항상 수정이 필요할때는 그 값을 썼던 모든 리터럴 값을 변경이 필요 할 것이다. 하지만 상수를 사용하면 한상 같은 값을 가지고 있는 변수가 생겨 그 변수만 바꾸어 주면 고정된 값들을 얻을 수 있을 것이다.

---

### 리터럴의 타입과 접미사

---

- 논리형: false, true -> 접미사 없음 - 정수형: 123, 0b0101, 077, 0xFF,100L -> L - 실수형: 3.14, 3.0e8, 1.4f,0x1,0p-1 -> f,d - 문자형:‘A’, ‘1’,‘’ -> 없음 - 문자열: “ABC”,“123”,“A”,“true” -> 없음

---

JDK1.7부터 정수형 리터럴에 _ 구분자 사용가능 ex) 100_000_000_000L

---

### 타입의 불일치

---

리터널 타입과 저장될 변수 타입은 일치하는게 정상 하지만 넓은 변수 타입에 좁은 리터널값 저장 가능 - int -> int (o) - int -> long(o) - float -> double(o) - double -> float (x) - int -> byte (x)

---

### 문자 리터럴 과 문자열 리터럴

---

- 문자 리터럴: ‘값’으로 싸져있는 값 - char ch = ’J’; - 문자열 리터럴: “값”으로 싸져있는 값 - String name = “Java”;

---

#### 문자열 초기화 > 문자열 리터럴은 ""안에 아무런 문자도 없어도 가능 하지만 ‘’은 불가능 >> String str = ""; //가능 >> char ch =’‘; //불가능 >> char ch =’ ’; //공백으로 초기화

---

#### 문자열의 결합

---

```
java String name  = "Ja" + "va"; String str = name + 8.0; // Java8.0 출력
```

---

> 문자열 + 모든 타입 -> 문자열 + 문자열 -> 문자열 > 모든 타입 + 문자열 -> 문자열 + 문자열 -> 문자열

---

예제는 스킵 (예제 2-3)

---

## 2.3 형식화된 출력 - printf()

> println 은 값을 변경하면서 출력할수 없다는 고정적 특성이 있다
이에 다른 변수를 출력하고 싶을때 사용하는 printf() 메서드
printf 는 println과 달리 출력후 줄바꿈 안됨
>

### 지시자

- %b: 불리언(boolean) 형식으로 출력
- %d : 10진(decimal) 정수의 형식으로 출력
- %o : 8진(octal) 정수의 형식으로 출력
- %x, %X : 16진(hexa-decimal) 정수의 형식으로 출력
- %f : 부동 소수점(floating-point)의 형식으로 출력
- %e, %E: 지수(exponent) 표현식의 형식으로 출력
- %c: 문자(character)로 출력
- %s: 문자열(string)로 출력

## 2.4 화면에서 입력받기 - Scanner

### 자바의 화면으로 부터 입력받기 방법

- JDK 1.6에 추가된 Console 클래스
- Scanner 클래스

### Scanner 클래스 사용방법

```java
import  java.util.*; // 다 import하면 memory 낭비//객체 생성Scanner scanner = new Scanner(System.in); //Scanner 클래스 객체 생성
```

### Scanner 클래스의 사용 메서드

- nextLine: 문자열 반환
- nextInt():정수형 반환
- nextFloat(): 소수형 반환

# 진법

## 3.1 10진법과 2진법

- 10진법: 우리가 일상생활에서 주로 사용하는 것
    - 1946년 개발된 애니악은 사람에게 익숙한 10진법을 사용하도록 설계되었으나 전기화로는 전압이 불안정하여 전압을 10단계로 나누어 처리하는 데 한계가 있다
    - 1950년 개발된 에드박은 단 두가지 단계 전기가 흐르면 1 흐르지 않으면 0 만으로 동작하도록 설계되었다
- 2진법: 컴퓨터가 사용하는 수의 체계
- 16진법 : 2진법, 10진접을 줄이기 위해 사용

## 3.2 비트(bit)와 바이트(byte)

- 비트: 한자리의 2진수 1비트는 컴퓨터가 값을 저장할 수 있는 최소 단위
- 바이트: 비트가 8개 묶여 있는 단위
- 워드: CPU가 한 번에 처리 할 수 있는 데이터의 크기

### **n비트로 표혈할 수 있는 10진수**

- **값의 개수 : 2ⁿ** ( 256 )
- **값의 법위 : 0 ~ 2ⁿ -1**

## 3.3 8진법과 16진법

- 8진수: 2진수 3자리를 한자리로 표현할 수 있는 방법
- 16진수: 2진수 4자리를 한자리로 표혈 할 수 있는 방법

### 2진수를 8진수, 16진수로 변환

- 2진수 -> 8진수: 2진수를 뒤에서부터 3자리씩 끊어서 그에 해당하는 8진수로 바꾼다 - 2진수 -> 16진수: 2진수를 4자리씩 끊어서 그에 해당하는 16진수로 바꾼다.

## 3.4 정수의 진법 변환

### 10진수를 n진수로 변환

해당 수를 나누고자 하는 진수로 나눌수 없을때 까지 나눈후 나머지를 거꾸로 읽는다

## 3.5 실수의 진법변환

### 10진 소수점수를 2진 소수점수로 변환하는 방법

10진 소수점수를 2진 소수점수로 변환하는 방법은 이와 반대로 10진 소수점수에 2를 계속 곱한다.

1. 10진 소수에 2를 곱한다
2. 위의 결과에서 소수부만 가져다가 다시 2를 곱한다
3. 1 과 2의 과정을 소수부가 0이 될 때까지 반복한다

## 3.6 음수의 2진 표현 - 2의 보수법

### 2의 보수란?

- 어떤 수를 커다란 2의 제곱수에서 빼서 얻은 이진수이다.
    - 주어진 이진수보다 한 자리 높고 가장 높은 자리가 1이며 나머지가 0인 수에서 주어진 수를 빼서 얻은 수가 2의 보수이다.
    - 주어진 이진수의 모든 자리의 숫자를 반전(0을 1로, 1을 0으로)시킨 뒤 여기에 1을 더하면 2의 보수를 얻을 수 있다.

8자리의 이진수 01001011(십진수로 75)의 2의 보수를 구하면 아래와 같다.

100000000 (8+1=9자리) –> 256
-) 01001011 (8자리) —> 75
=================
10110101 (8자리) —> 181 1의 보수를 이용하여 2의 보수를 구하면 아래와 같다.

01001011 의 모든 자리의 수를 반전시킨다. 10110100 (이것을 1의 보수라고 부른다) 여기에 1을 더한다. 10110100 —> 180 +) 00000001 —> 1 ———– 10110101 —> 181

# 4. 기본형(primitive type)

### 기본형이란?

실제 값을 담을 수 있는 변수의 타입 개수는 8개로 구분하며 크게는 논리, 문자,정수,실수 로 구분

## 4.1 논리형

### boolean

가능한 값: true, false (defalut) 크기 : 1byte on/off , yes/no 등 논리구현에 주로 사용 ## 4.2 문자형 ### char 가능한 값: 하나의 문자만 저장 ‘A’,‘B’ 등 크기: 2byte char 타입은 사칙연산이 가능하고 유니코드로 저장된다. ex) ‘A’ == 65
char <–> int 가능

## 4.3 정수형

### byte

가능한 값: -128~127 크기: 1byte ### short 가능한 값: -32768 ~ 32,767 크기: 2 byte ### int 가능한 값: -2,147,483,648 ~ 2,147,483,467 크기: 4byte ### long 가능한 값: -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 크기 : 8byte

### 정수 선택기준

정수 값의 범위에 따라 4개의 정수형중 하나를 선택하면 되겠만, int를 사용하는것을 권장

### 정수형 오버플로우

연산과정에서 해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것

- 오버플로우 공식 최댓값＋1 → 최솟값 최솟값－1 → 최댓값

### 부호 있는 정수의 오버플로우

부호 없는 정수와 부호 있는 정수는 표현 범위(최댓값과 최솟값)가 다르기 때문에 오버플로우가 발생하는 시점이 다르다.
부호 없는 정수는 2진수로 ’0000’이 될 때 오버플로우가 발생하고,
부호 있는 정수는 0에서 1이 될 때 오버플로우가 발생한다.

## 4.4 실수형

### flaot

가능한 값:(+/-)1.4E-45 ~ (+/-)3.4028235E38 크기 : 4byte

### double

가능한 값:(+/-)4.9E-324 ~ (+/-)1.7976931348623157E308 크기 : 8byte

### 실수형의 저장형식

1. 정밀도 float : 7자리 0.1234567xxxx (단정도 정밀도) double : 15자리 0.123456789012345xxxxx… (배정도 정밀도) 3.14 3.141592 -> 더 정밀한 표현이다.

    ```
                     지수(E : 8) 가수(M : 23)
    ```

   float [S][1][2][3] [4][5][6][7] [8][1][][] [][][][] [][][][] [][][][] [][][][] [][][][].
   기저법(특정수) 127 + 3 == 130.
   지수(E : 11) 가수(M : 52).
   double [S][1][2][3] [4][5][6][7] [8][9][10][11] [1][][][] [][][][] [][][][] [][][][] [][][][].
   [][][][] [][][][] [][][][] [][][][] [][][][] [][][][] [][][][] [][][][].


S 부호 : 0이면 양수, 1이면 음수

E 지수 : 부호있는 정수

M 가수 : 실제값을 저장하는 부분

1. 실수형의 저장형식

실수형은 값은 [부동소수점] 형태로 저장한다.

└ +-M * 2^E 실수를 표현한 것

예) 10진소수 9.1234567 (유한소수)

2진소수 9 -> 1001

```
          0..1234567 -> 000111111001101011011011...
```

1001.000111111001101011011011… : 오차가 있는 값으로 저장됨. (2진수로는 무한소수)

정규화 : 소수점 위치가 다르기 때문에 고정 해주는 작업

└ 1.XXX * 2^E

1.001000111111001101011011011… * 2^3 가수 M E

2진수로 표현했을때 무한 소수 & 자리수를 벗어나면 오차 범위가 생긴다. **BigDecimal** (실무자는 오차 범위를 줄이기 위해 이 명령어 사용)

# 5.형변환

## 5.1 형변환(캐스팅,casting)이란?

형변환이란, 변수 또는 상수의 타입을 다른 타입으로 변환하는 것 ## 5.2 형변환 방법 (타입)피연산자 사용되는 ()는 ‘케스트 연산자’ 또는 ’형변환 연산자’라고 한다. > 피연산자인 변수 d인 값은 형변환 후에도 아무런 변화가 없다

## 5.3 정수형의 형변환

- 큰타입 -> 작은타입: 크기의 차이만큼 잘려나간다 -> 값 손실(loss of data) 발생
- 작은타입 -> 큰타입: 저장공간이 부족으로 잘려나가는 일이 없으므로 빈공간은 0또는 1로 채워진다
    - 양수는 0으로 음수는 1로 채워진다

## 5.4 실수형 간의 형변환

- 정수형과 같다

## 5.5 정수형과 실수형 간의 형변환

### 정수형을 실수형으로 변환

> 정수를 2진수로 변환한 다음 정규화를 거쳐 실수의 저장형식으로 저장
>

실수형은 정수형보다 훨씬 큰 저장범위를 가져 무리가 없다
ex) 123(int) <- 123.0(double)

### 실수형 정수형 형변환

> 실수형에서 정수형으로 형변환시 소수점 아래는 버려진다
>

ex) 123.33(float) <- 123(int)

## 5.6 자동형변환

타입간 대입이나 연산할때 타입을 일치 시켜야 하지만 경우에 따라 편의상의 이유로 형변환을 생략할수 있다.
형변환은 컴파일에서 자동으로 이루어진다

```java
float f = 1234; // 형변환 생략 float f = (float)1234; 같음
```

정수형을 실수형에 넣을때 자동으로 형변환이 이루어짐

값의 범위가 작을때

```java
byte b = 1000; //에러 byte범위 벗어남
```

**에러메세지는 ‘incompatible types: possible lossy conversion from int to byte’** **앞에서 배운 내용과 같이 값 손실이 발생 할 수 있다.
그러나 다음과 같이 명시적으로 형변환 해줬을 때는 의도로 간주하고 에러를 발생하지 않는다.**

```java
char ch = (char) 1000; //명시적 형변환 -> d
```

연산과정에서 형변환

```java
int i = 3;double d = 1.0 + i // double d = 1.0 + (double)i; 형변환 일어남
```

### 자동 형변환의 규칙

> 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환
>

> boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다기본형과 참조형은 서로 형변환할 수 없다.서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 없다
>