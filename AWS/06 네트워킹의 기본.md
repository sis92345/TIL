# 1. IP

<aside>
🍽️ 컴퓨터 사이에 통신을 하려면 컴퓨터의 위치값을 알아야 한다. 이 위치 값을 IP 주소라 지칭한다 (IPv412)

</aside>

- 172.16.254.1 → 8bit 단위로 이룸, 각 단위를 옥텟이라고 한다.
    - 172 : 10101100
    - 16   : 0010000
    - 254 : 11111110,
    - 1 : 00000001
- 2^32가 IPv4에서 존재할 수 있는 IP → IP가 부족하기 때문에 서브넷이라는 개념이 추가

## 1-1. IPV4 Classes

첫번째 옥텟의 앞자리 숫자로 구분

- A Class
    - 0———-,————,————,————
    - 네트워크 비트는 첫번째 옥텟의 0을 제외한 나머지 비트 ( 7자리 )
    - 2^24개의 HOST(IP)
    - A Class는 2^7개의 네트워크
- B Class
    - 10———,————,————,————
    - 네트워크 비트는 첫번째, 두번째 옥텟의 10을 제외한 나머지 비트 ( 14자리 )
    - 2^16개의 HOST(IP)
    - A Class는 2^14개의 네트워크
- C Class
    - 110———,———-,————,————
    - 네트워크 비트는 첫번째, 두번째 옥텟의 110을 제외한 나머지 비트 ( 14자리 )
    - 2^21개의 HOST(IP)
    - A Class는 2^8개의 네트워크
- 설명

  각 옥텟은 아래처럼 구분할 수 있다.

    - 0———- : Network bit ( 8자리중 0 빼고 나머지 )
    - ————  : Host bit
    - ————  : Host bit
    - ————  : Host bit

  Network bit는 네트워크를 표현하는 비트로, 해당 IP 주소가 어떤 네트워크에 존재하는지 표현한다.

  Host bit는 특정 네트워크 안에서 Host를 표현하는 비트임

  호스트 비트는 네트워크 비트에 종속된다. 즉 A라는 네트워크에 호스트가 10개라는 의미는 A라는 네트워크에 IP주소가 10개가 있다는 의미

  하나의 네트워크에는 2^24개의 HOST(IP)를 보유하고 있으며, A Class는 2^7개의 네트워크가 존재함


A/B/C Class로 갈수록 네트워크의 개수가 커지며, 호스트 개수가 작아진다.

일반적인 수준에서는 큰 네트워크를 보유할 필요가 없기 때문에 C Class를 사용한다.

예

211.11.124.2은 몇 클래스에 존재하며 몇개의 호스트를 가지는가

정답 : Class

11010011.00001011.01111011.00000001 → C Class

따라서 호스트비트는 211.11.124에서 2임

따라서 이 네트워크에 존재 가능한 호스트의 수는 211.11.124.0~211.11.124.255

## 1-2. 서브넷 (Sub Network)

IP 주소가 부족하니, 한 사람이 한 IP를 보유하는 것이 아니라 네트워크를 분할해서 사용하는 것이 기본 맥락

예를 들어 아래 네트워크가 존재한다고 하자

211.11.124.2

- 211.11.124.0~255
    - 211.11.124.0~127 ( 11010011.00001011.01111011.00000000 ~ 11010011.00001011.01111011.01111111 )
        - Subnet A
            - 11010011.00001011.01111011.**0**는 고정
    - 211.11.124.127~255 ( 11010011.00001011.01111011.10000000 ~ 11010011.00001011.01111011.11111111 )
        - Subnet B
            - 11010011.00001011.01111011.**1**는 고정

위 고정 규칙에 따라서 표기한다.

`Subnet 고정부의 첫 IP 주소/각 옥텟에서 고정된 비트개수(8+8+8+1)` 이것이 CIDR

Subnet A 대역은 211.11.124.0/25

Subnet B 대역은 211.11.125.128/25

# 2. stateless, stateful

- 정보
    - Client
        - 175.34.136.133
    - Server
        - 13.10.100.100
- Client가 Server에 Request


    | source | 175.34.136.133 | 1025 |
    | --- | --- | --- |
    | destination | 13.10.100.100 | 80 |
    
    위 정보는 80번 서버로 request한 후 1025 port로 서버에서 response를 준 것
    
    - 여기서 서버입장에서 응답을 보낼 1025(임시포트)는 outbound
    - 요청을 받을 80번 포트는 inbound
- Server가 Client에 response


    | source | 13.10.100.100 | 80 |
    | --- | --- | --- |
    | destination | 175.34.136.133 | 1025 |

위 상황에서 stateful한 설정은 요청 정보를 기억한다. 서버에서 outbound를 none으로 설정하고 inbound를 80으로 설정하면 이 정보를 기억하고 있다가 1025번 포트로 응답을 보낼 수 있다. 반면 stateless는 이 정보를 기억하지 못한다. inbound로 요청이 들어왔어도 응답을 보낼 때 outbound가 없으므로 응답을 보낼 수 없다.

[[AWS] NACL vs Security Group (Stateless와 Stateful 차이)](https://honglab.tistory.com/153)